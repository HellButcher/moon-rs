
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

use libc::{c_void,c_int,c_uint,c_char};

/* automatically generated by rust-bindgen */

pub const LUA_MAXCAPTURES: c_int = 32;
pub const LUA_IDSIZE: c_int = 60;
pub const LUA_VERSION_NUM: c_int = 501;
pub const LUA_MULTRET: c_int = -1;
pub const LUA_REGISTRYINDEX: c_int = -10000;
pub const LUA_ENVIRONINDEX: c_int = -10001;
pub const LUA_GLOBALSINDEX: c_int = -10002;
pub const LUA_YIELD: c_int = 1;
pub const LUA_ERRRUN: c_int = 2;
pub const LUA_ERRSYNTAX: c_int = 3;
pub const LUA_ERRMEM: c_int = 4;
pub const LUA_ERRERR: c_int = 5;
pub const LUA_TNONE: c_int = -1;
pub const LUA_TNIL: c_int = 0;
pub const LUA_TBOOLEAN: c_int = 1;
pub const LUA_TLIGHTUSERDATA: c_int = 2;
pub const LUA_TNUMBER: c_int = 3;
pub const LUA_TSTRING: c_int = 4;
pub const LUA_TTABLE: c_int = 5;
pub const LUA_TFUNCTION: c_int = 6;
pub const LUA_TUSERDATA: c_int = 7;
pub const LUA_TTHREAD: c_int = 8;
pub const LUA_MINSTACK: c_int = 20;
pub const LUA_GCSTOP: c_int = 0;
pub const LUA_GCRESTART: c_int = 1;
pub const LUA_GCCOLLECT: c_int = 2;
pub const LUA_GCCOUNT: c_int = 3;
pub const LUA_GCCOUNTB: c_int = 4;
pub const LUA_GCSTEP: c_int = 5;
pub const LUA_GCSETPAUSE: c_int = 6;
pub const LUA_GCSETSTEPMUL: c_int = 7;
pub const LUA_HOOKCALL: c_int = 0;
pub const LUA_HOOKRET: c_int = 1;
pub const LUA_HOOKLINE: c_int = 2;
pub const LUA_HOOKCOUNT: c_int = 3;
pub const LUA_HOOKTAILRET: c_int = 4;
pub const LUA_MASKCALL: c_int = 1;
pub const LUA_MASKRET: c_int = 2;
pub const LUA_MASKLINE: c_int = 4;
pub const LUA_MASKCOUNT: c_int = 8;
pub const LUA_ERRFILE: c_int = 6;
pub const LUA_NOREF: c_int = -2;
pub const LUA_REFNIL: c_int = -1;
pub const LUAJIT_VERSION_NUM: c_int = 20005;
pub const LUAJIT_MODE_MASK: c_int = 255;
pub const LUAJIT_MODE_OFF: c_int = 0;
pub const LUAJIT_MODE_ON: c_int = 256;
pub const LUAJIT_MODE_FLUSH: c_int = 512;
pub type va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lua_State {
  _unused: [u8; 0],
}
pub type lua_CFunction =
  ::core::option::Option<unsafe extern "C" fn(L: *mut lua_State) -> c_int>;
pub type lua_Reader = ::core::option::Option<
  unsafe extern "C" fn(
    L: *mut lua_State,
    ud: *mut c_void,
    sz: *mut usize,
  ) -> *const c_char,
>;
pub type lua_Writer = ::core::option::Option<
  unsafe extern "C" fn(
    L: *mut lua_State,
    p: *const c_void,
    sz: usize,
    ud: *mut c_void,
  ) -> c_int,
>;
pub type lua_Alloc = ::core::option::Option<
  unsafe extern "C" fn(
    ud: *mut c_void,
    ptr: *mut c_void,
    osize: usize,
    nsize: usize,
  ) -> *mut c_void,
>;
pub type lua_Number = f64;
pub type lua_Integer = isize;
extern "C" {
  pub fn lua_newstate(f: lua_Alloc, ud: *mut c_void) -> *mut lua_State;
}
extern "C" {
  pub fn lua_close(L: *mut lua_State);
}
extern "C" {
  pub fn lua_newthread(L: *mut lua_State) -> *mut lua_State;
}
extern "C" {
  pub fn lua_atpanic(L: *mut lua_State, panicf: lua_CFunction) -> lua_CFunction;
}
extern "C" {
  pub fn lua_gettop(L: *mut lua_State) -> c_int;
}
extern "C" {
  pub fn lua_settop(L: *mut lua_State, idx: c_int);
}
extern "C" {
  pub fn lua_pushvalue(L: *mut lua_State, idx: c_int);
}
extern "C" {
  pub fn lua_remove(L: *mut lua_State, idx: c_int);
}
extern "C" {
  pub fn lua_insert(L: *mut lua_State, idx: c_int);
}
extern "C" {
  pub fn lua_replace(L: *mut lua_State, idx: c_int);
}
extern "C" {
  pub fn lua_checkstack(L: *mut lua_State, sz: c_int) -> c_int;
}
extern "C" {
  pub fn lua_xmove(from: *mut lua_State, to: *mut lua_State, n: c_int);
}
extern "C" {
  pub fn lua_isnumber(L: *mut lua_State, idx: c_int) -> c_int;
}
extern "C" {
  pub fn lua_isstring(L: *mut lua_State, idx: c_int) -> c_int;
}
extern "C" {
  pub fn lua_iscfunction(L: *mut lua_State, idx: c_int) -> c_int;
}
extern "C" {
  pub fn lua_isuserdata(L: *mut lua_State, idx: c_int) -> c_int;
}
extern "C" {
  pub fn lua_type(L: *mut lua_State, idx: c_int) -> c_int;
}
extern "C" {
  pub fn lua_typename(L: *mut lua_State, tp: c_int) -> *const c_char;
}
extern "C" {
  pub fn lua_equal(L: *mut lua_State, idx1: c_int, idx2: c_int) -> c_int;
}
extern "C" {
  pub fn lua_rawequal(L: *mut lua_State, idx1: c_int, idx2: c_int) -> c_int;
}
extern "C" {
  pub fn lua_lessthan(L: *mut lua_State, idx1: c_int, idx2: c_int) -> c_int;
}
extern "C" {
  pub fn lua_tonumber(L: *mut lua_State, idx: c_int) -> lua_Number;
}
extern "C" {
  pub fn lua_tointeger(L: *mut lua_State, idx: c_int) -> lua_Integer;
}
extern "C" {
  pub fn lua_toboolean(L: *mut lua_State, idx: c_int) -> c_int;
}
extern "C" {
  pub fn lua_tolstring(L: *mut lua_State, idx: c_int, len: *mut usize)
    -> *const c_char;
}
extern "C" {
  pub fn lua_objlen(L: *mut lua_State, idx: c_int) -> usize;
}
extern "C" {
  pub fn lua_tocfunction(L: *mut lua_State, idx: c_int) -> lua_CFunction;
}
extern "C" {
  pub fn lua_touserdata(L: *mut lua_State, idx: c_int) -> *mut c_void;
}
extern "C" {
  pub fn lua_tothread(L: *mut lua_State, idx: c_int) -> *mut lua_State;
}
extern "C" {
  pub fn lua_topointer(L: *mut lua_State, idx: c_int) -> *const c_void;
}
extern "C" {
  pub fn lua_pushnil(L: *mut lua_State);
}
extern "C" {
  pub fn lua_pushnumber(L: *mut lua_State, n: lua_Number);
}
extern "C" {
  pub fn lua_pushinteger(L: *mut lua_State, n: lua_Integer);
}
extern "C" {
  pub fn lua_pushlstring(L: *mut lua_State, s: *const c_char, l: usize);
}
extern "C" {
  pub fn lua_pushstring(L: *mut lua_State, s: *const c_char);
}
extern "C" {
  pub fn lua_pushvfstring(
    L: *mut lua_State,
    fmt: *const c_char,
    argp: *mut __va_list_tag,
  ) -> *const c_char;
}
extern "C" {
  pub fn lua_pushfstring(L: *mut lua_State, fmt: *const c_char, ...) -> *const c_char;
}
extern "C" {
  pub fn lua_pushcclosure(L: *mut lua_State, fn_: lua_CFunction, n: c_int);
}
extern "C" {
  pub fn lua_pushboolean(L: *mut lua_State, b: c_int);
}
extern "C" {
  pub fn lua_pushlightuserdata(L: *mut lua_State, p: *mut c_void);
}
extern "C" {
  pub fn lua_pushthread(L: *mut lua_State) -> c_int;
}
extern "C" {
  pub fn lua_gettable(L: *mut lua_State, idx: c_int);
}
extern "C" {
  pub fn lua_getfield(L: *mut lua_State, idx: c_int, k: *const c_char);
}
extern "C" {
  pub fn lua_rawget(L: *mut lua_State, idx: c_int);
}
extern "C" {
  pub fn lua_rawgeti(L: *mut lua_State, idx: c_int, n: c_int);
}
extern "C" {
  pub fn lua_createtable(L: *mut lua_State, narr: c_int, nrec: c_int);
}
extern "C" {
  pub fn lua_newuserdata(L: *mut lua_State, sz: usize) -> *mut c_void;
}
extern "C" {
  pub fn lua_getmetatable(L: *mut lua_State, objindex: c_int) -> c_int;
}
extern "C" {
  pub fn lua_getfenv(L: *mut lua_State, idx: c_int);
}
extern "C" {
  pub fn lua_settable(L: *mut lua_State, idx: c_int);
}
extern "C" {
  pub fn lua_setfield(L: *mut lua_State, idx: c_int, k: *const c_char);
}
extern "C" {
  pub fn lua_rawset(L: *mut lua_State, idx: c_int);
}
extern "C" {
  pub fn lua_rawseti(L: *mut lua_State, idx: c_int, n: c_int);
}
extern "C" {
  pub fn lua_setmetatable(L: *mut lua_State, objindex: c_int) -> c_int;
}
extern "C" {
  pub fn lua_setfenv(L: *mut lua_State, idx: c_int) -> c_int;
}
extern "C" {
  pub fn lua_call(L: *mut lua_State, nargs: c_int, nresults: c_int);
}
extern "C" {
  pub fn lua_pcall(
    L: *mut lua_State,
    nargs: c_int,
    nresults: c_int,
    errfunc: c_int,
  ) -> c_int;
}
extern "C" {
  pub fn lua_cpcall(L: *mut lua_State, func: lua_CFunction, ud: *mut c_void) -> c_int;
}
extern "C" {
  pub fn lua_load(
    L: *mut lua_State,
    reader: lua_Reader,
    dt: *mut c_void,
    chunkname: *const c_char,
  ) -> c_int;
}
extern "C" {
  pub fn lua_dump(L: *mut lua_State, writer: lua_Writer, data: *mut c_void) -> c_int;
}
extern "C" {
  pub fn lua_yield(L: *mut lua_State, nresults: c_int) -> c_int;
}
extern "C" {
  pub fn lua_resume(L: *mut lua_State, narg: c_int) -> c_int;
}
extern "C" {
  pub fn lua_status(L: *mut lua_State) -> c_int;
}
extern "C" {
  pub fn lua_gc(L: *mut lua_State, what: c_int, data: c_int) -> c_int;
}
extern "C" {
  pub fn lua_error(L: *mut lua_State) -> c_int;
}
extern "C" {
  pub fn lua_next(L: *mut lua_State, idx: c_int) -> c_int;
}
extern "C" {
  pub fn lua_concat(L: *mut lua_State, n: c_int);
}
extern "C" {
  pub fn lua_getallocf(L: *mut lua_State, ud: *mut *mut c_void) -> lua_Alloc;
}
extern "C" {
  pub fn lua_setallocf(L: *mut lua_State, f: lua_Alloc, ud: *mut c_void);
}
extern "C" {
  pub fn lua_setlevel(from: *mut lua_State, to: *mut lua_State);
}
pub type lua_Hook =
  ::core::option::Option<unsafe extern "C" fn(L: *mut lua_State, ar: *mut lua_Debug)>;
extern "C" {
  pub fn lua_getstack(L: *mut lua_State, level: c_int, ar: *mut lua_Debug) -> c_int;
}
extern "C" {
  pub fn lua_getinfo(
    L: *mut lua_State,
    what: *const c_char,
    ar: *mut lua_Debug,
  ) -> c_int;
}
extern "C" {
  pub fn lua_getlocal(
    L: *mut lua_State,
    ar: *const lua_Debug,
    n: c_int,
  ) -> *const c_char;
}
extern "C" {
  pub fn lua_setlocal(
    L: *mut lua_State,
    ar: *const lua_Debug,
    n: c_int,
  ) -> *const c_char;
}
extern "C" {
  pub fn lua_getupvalue(
    L: *mut lua_State,
    funcindex: c_int,
    n: c_int,
  ) -> *const c_char;
}
extern "C" {
  pub fn lua_setupvalue(
    L: *mut lua_State,
    funcindex: c_int,
    n: c_int,
  ) -> *const c_char;
}
extern "C" {
  pub fn lua_sethook(
    L: *mut lua_State,
    func: lua_Hook,
    mask: c_int,
    count: c_int,
  ) -> c_int;
}
extern "C" {
  pub fn lua_gethook(L: *mut lua_State) -> lua_Hook;
}
extern "C" {
  pub fn lua_gethookmask(L: *mut lua_State) -> c_int;
}
extern "C" {
  pub fn lua_gethookcount(L: *mut lua_State) -> c_int;
}
extern "C" {
  pub fn lua_upvalueid(L: *mut lua_State, idx: c_int, n: c_int) -> *mut c_void;
}
extern "C" {
  pub fn lua_upvaluejoin(
    L: *mut lua_State,
    idx1: c_int,
    n1: c_int,
    idx2: c_int,
    n2: c_int,
  );
}
extern "C" {
  pub fn lua_loadx(
    L: *mut lua_State,
    reader: lua_Reader,
    dt: *mut c_void,
    chunkname: *const c_char,
    mode: *const c_char,
  ) -> c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lua_Debug {
  pub event: c_int,
  pub name: *const c_char,
  pub namewhat: *const c_char,
  pub what: *const c_char,
  pub source: *const c_char,
  pub currentline: c_int,
  pub nups: c_int,
  pub linedefined: c_int,
  pub lastlinedefined: c_int,
  pub short_src: [c_char; 60usize],
  pub i_ci: c_int,
}
#[test]
fn bindgen_test_layout_lua_Debug() {
  assert_eq!(
    ::core::mem::size_of::<lua_Debug>(),
    120usize,
    concat!("Size of: ", stringify!(lua_Debug))
  );
  assert_eq!(
    ::core::mem::align_of::<lua_Debug>(),
    8usize,
    concat!("Alignment of ", stringify!(lua_Debug))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<lua_Debug>())).event as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(lua_Debug),
      "::",
      stringify!(event)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<lua_Debug>())).name as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(lua_Debug),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<lua_Debug>())).namewhat as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(lua_Debug),
      "::",
      stringify!(namewhat)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<lua_Debug>())).what as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(lua_Debug),
      "::",
      stringify!(what)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<lua_Debug>())).source as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(lua_Debug),
      "::",
      stringify!(source)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<lua_Debug>())).currentline as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(lua_Debug),
      "::",
      stringify!(currentline)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<lua_Debug>())).nups as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(lua_Debug),
      "::",
      stringify!(nups)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<lua_Debug>())).linedefined as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(lua_Debug),
      "::",
      stringify!(linedefined)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<lua_Debug>())).lastlinedefined as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(lua_Debug),
      "::",
      stringify!(lastlinedefined)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<lua_Debug>())).short_src as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(lua_Debug),
      "::",
      stringify!(short_src)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<lua_Debug>())).i_ci as *const _ as usize },
    116usize,
    concat!(
      "Offset of field: ",
      stringify!(lua_Debug),
      "::",
      stringify!(i_ci)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct luaL_Reg {
  pub name: *const c_char,
  pub func: lua_CFunction,
}
#[test]
fn bindgen_test_layout_luaL_Reg() {
  assert_eq!(
    ::core::mem::size_of::<luaL_Reg>(),
    16usize,
    concat!("Size of: ", stringify!(luaL_Reg))
  );
  assert_eq!(
    ::core::mem::align_of::<luaL_Reg>(),
    8usize,
    concat!("Alignment of ", stringify!(luaL_Reg))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<luaL_Reg>())).name as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(luaL_Reg),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<luaL_Reg>())).func as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(luaL_Reg),
      "::",
      stringify!(func)
    )
  );
}
extern "C" {
  pub fn luaL_openlib(
    L: *mut lua_State,
    libname: *const c_char,
    l: *const luaL_Reg,
    nup: c_int,
  );
}
extern "C" {
  pub fn luaL_register(L: *mut lua_State, libname: *const c_char, l: *const luaL_Reg);
}
extern "C" {
  pub fn luaL_getmetafield(
    L: *mut lua_State,
    obj: c_int,
    e: *const c_char,
  ) -> c_int;
}
extern "C" {
  pub fn luaL_callmeta(L: *mut lua_State, obj: c_int, e: *const c_char) -> c_int;
}
extern "C" {
  pub fn luaL_typerror(
    L: *mut lua_State,
    narg: c_int,
    tname: *const c_char,
  ) -> c_int;
}
extern "C" {
  pub fn luaL_argerror(
    L: *mut lua_State,
    numarg: c_int,
    extramsg: *const c_char,
  ) -> c_int;
}
extern "C" {
  pub fn luaL_checklstring(
    L: *mut lua_State,
    numArg: c_int,
    l: *mut usize,
  ) -> *const c_char;
}
extern "C" {
  pub fn luaL_optlstring(
    L: *mut lua_State,
    numArg: c_int,
    def: *const c_char,
    l: *mut usize,
  ) -> *const c_char;
}
extern "C" {
  pub fn luaL_checknumber(L: *mut lua_State, numArg: c_int) -> lua_Number;
}
extern "C" {
  pub fn luaL_optnumber(L: *mut lua_State, nArg: c_int, def: lua_Number) -> lua_Number;
}
extern "C" {
  pub fn luaL_checkinteger(L: *mut lua_State, numArg: c_int) -> lua_Integer;
}
extern "C" {
  pub fn luaL_optinteger(L: *mut lua_State, nArg: c_int, def: lua_Integer) -> lua_Integer;
}
extern "C" {
  pub fn luaL_checkstack(L: *mut lua_State, sz: c_int, msg: *const c_char);
}
extern "C" {
  pub fn luaL_checktype(L: *mut lua_State, narg: c_int, t: c_int);
}
extern "C" {
  pub fn luaL_checkany(L: *mut lua_State, narg: c_int);
}
extern "C" {
  pub fn luaL_newmetatable(L: *mut lua_State, tname: *const c_char) -> c_int;
}
extern "C" {
  pub fn luaL_checkudata(
    L: *mut lua_State,
    ud: c_int,
    tname: *const c_char,
  ) -> *mut c_void;
}
extern "C" {
  pub fn luaL_where(L: *mut lua_State, lvl: c_int);
}
extern "C" {
  pub fn luaL_error(L: *mut lua_State, fmt: *const c_char, ...) -> c_int;
}
extern "C" {
  pub fn luaL_checkoption(
    L: *mut lua_State,
    narg: c_int,
    def: *const c_char,
    lst: *const *const c_char,
  ) -> c_int;
}
extern "C" {
  pub fn luaL_ref(L: *mut lua_State, t: c_int) -> c_int;
}
extern "C" {
  pub fn luaL_unref(L: *mut lua_State, t: c_int, ref_: c_int);
}
extern "C" {
  pub fn luaL_loadfile(L: *mut lua_State, filename: *const c_char) -> c_int;
}
extern "C" {
  pub fn luaL_loadbuffer(
    L: *mut lua_State,
    buff: *const c_char,
    sz: usize,
    name: *const c_char,
  ) -> c_int;
}
extern "C" {
  pub fn luaL_loadstring(L: *mut lua_State, s: *const c_char) -> c_int;
}
extern "C" {
  pub fn luaL_newstate() -> *mut lua_State;
}
extern "C" {
  pub fn luaL_gsub(
    L: *mut lua_State,
    s: *const c_char,
    p: *const c_char,
    r: *const c_char,
  ) -> *const c_char;
}
extern "C" {
  pub fn luaL_findtable(
    L: *mut lua_State,
    idx: c_int,
    fname: *const c_char,
    szhint: c_int,
  ) -> *const c_char;
}
extern "C" {
  pub fn luaL_fileresult(
    L: *mut lua_State,
    stat: c_int,
    fname: *const c_char,
  ) -> c_int;
}
extern "C" {
  pub fn luaL_execresult(L: *mut lua_State, stat: c_int) -> c_int;
}
extern "C" {
  pub fn luaL_loadfilex(
    L: *mut lua_State,
    filename: *const c_char,
    mode: *const c_char,
  ) -> c_int;
}
extern "C" {
  pub fn luaL_loadbufferx(
    L: *mut lua_State,
    buff: *const c_char,
    sz: usize,
    name: *const c_char,
    mode: *const c_char,
  ) -> c_int;
}
extern "C" {
  pub fn luaL_traceback(
    L: *mut lua_State,
    L1: *mut lua_State,
    msg: *const c_char,
    level: c_int,
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct luaL_Buffer {
  pub p: *mut c_char,
  pub lvl: c_int,
  pub L: *mut lua_State,
  pub buffer: [c_char; 8192usize],
}
#[test]
fn bindgen_test_layout_luaL_Buffer() {
  assert_eq!(
    ::core::mem::size_of::<luaL_Buffer>(),
    8216usize,
    concat!("Size of: ", stringify!(luaL_Buffer))
  );
  assert_eq!(
    ::core::mem::align_of::<luaL_Buffer>(),
    8usize,
    concat!("Alignment of ", stringify!(luaL_Buffer))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<luaL_Buffer>())).p as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(luaL_Buffer),
      "::",
      stringify!(p)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<luaL_Buffer>())).lvl as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(luaL_Buffer),
      "::",
      stringify!(lvl)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<luaL_Buffer>())).L as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(luaL_Buffer),
      "::",
      stringify!(L)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<luaL_Buffer>())).buffer as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(luaL_Buffer),
      "::",
      stringify!(buffer)
    )
  );
}
extern "C" {
  pub fn luaL_buffinit(L: *mut lua_State, B: *mut luaL_Buffer);
}
extern "C" {
  pub fn luaL_prepbuffer(B: *mut luaL_Buffer) -> *mut c_char;
}
extern "C" {
  pub fn luaL_addlstring(B: *mut luaL_Buffer, s: *const c_char, l: usize);
}
extern "C" {
  pub fn luaL_addstring(B: *mut luaL_Buffer, s: *const c_char);
}
extern "C" {
  pub fn luaL_addvalue(B: *mut luaL_Buffer);
}
extern "C" {
  pub fn luaL_pushresult(B: *mut luaL_Buffer);
}
extern "C" {
  pub fn luaL_openlibs(L: *mut lua_State);
}
pub const LUAJIT_MODE_ENGINE: c_int = 0;
pub const LUAJIT_MODE_DEBUG: c_int = 1;
pub const LUAJIT_MODE_FUNC: c_int = 2;
pub const LUAJIT_MODE_ALLFUNC: c_int = 3;
pub const LUAJIT_MODE_ALLSUBFUNC: c_int = 4;
pub const LUAJIT_MODE_TRACE: c_int = 5;
pub const LUAJIT_MODE_WRAPCFUNC: c_int = 16;
pub const LUAJIT_MODE_MAX: c_int = 17;
pub type _bindgen_ty_1 = u32;
extern "C" {
  pub fn luaJIT_setmode(L: *mut lua_State, idx: c_int, mode: c_int) -> c_int;
}
extern "C" {
  pub fn luaJIT_version_2_0_5();
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
  pub gp_offset: c_uint,
  pub fp_offset: c_uint,
  pub overflow_arg_area: *mut c_void,
  pub reg_save_area: *mut c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
  assert_eq!(
    ::core::mem::size_of::<__va_list_tag>(),
    24usize,
    concat!("Size of: ", stringify!(__va_list_tag))
  );
  assert_eq!(
    ::core::mem::align_of::<__va_list_tag>(),
    8usize,
    concat!("Alignment of ", stringify!(__va_list_tag))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__va_list_tag),
      "::",
      stringify!(gp_offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(__va_list_tag),
      "::",
      stringify!(fp_offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__va_list_tag),
      "::",
      stringify!(overflow_arg_area)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__va_list_tag),
      "::",
      stringify!(reg_save_area)
    )
  );
}
